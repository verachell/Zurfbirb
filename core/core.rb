require 'sanitize'
include HTMLmarkup
include ZBcookies
include ZBcsrf

# require_relative everything in the directory specified in the argument.
# if the dir does not exist or is empty or contains files not ending in .rb, that is OK
# files not ending in .rb won't be loaded
# Returns true if directory exists and is not empty. A true return value does not
# automatically mean files were loaded - files may have all ended
# with something other than .rb.
# False is returned if directory does not exist or is empty
def req_all_in_dir(dir_from_root)
	temp_dir_from_root = DOC_ROOT.dup.concat("/", dir_from_root.dup)
	# if we don't duplicate as above, the concat command below permanently alters the dir_from_root
	# and this then affects the in_file method which is then reading from a globbed concatted dir
	if File.exist?(temp_dir_from_root) and File.directory?(temp_dir_from_root) and (Dir.empty?(temp_dir_from_root) == false)
		file_arr = Dir.glob(temp_dir_from_root.concat("/*.rb"))
		file_arr.each { |file| 
		require(file)}
		true
	else
		false
	end
end

# given a filename and optional dir name, returns a string containing its contents
def in_file(filename, dirname_from_root: $dir_lookup_arr, use_working_dir: true)
	# note that use_working_dir refers to the directory from which the ruby process was run
	# this is not the same as the directory relative to the file calling this method
	result = ""
	unless dirname_from_root.empty?
		fullname_arr = dirname_from_root.dup.map{|one_dir| 
		one_dir.dup.concat("/", filename)}
	end
	if use_working_dir
		fullname_arr.push(filename)
	end
	if fullname_arr.empty?
		return ""
	else
		fullname_arr.each{|one_full_filename| 
			if File.exist?(one_full_filename)
				existing_file = File.open(one_full_filename, "r")
				result = existing_file.read
            	break
			end 
		}
	end
	return result
end

# IMPORTANT - only use on files you are certain you have written yourself
# it is a security risk to use it on anything else, especially 
# anything a user types into forms. If you don't know what you are 
# doing, don't use this function at all!
# Given a string of text (e.g. html encoding a form) AND optional keyword arguments, 
# replaces any variables encoded in the string text as %%{varname} with 
# the string value of the keyword argument corresponding to the same index. 
# e.g. with arg of :name => "user" in optional args, then %%{name} in str is converted
# to the string value of the passed argument e.g. "user".
# One exception is the special variable name of %%{csrf} - if this is present
# it is substituted for a csrf form field automatically whose value
# is generated by the appropriate function in the csrf module. If doing this,
# don't include csrf in the optional arguments. You get this one "for free".
# If an expected key is missing in arguments, that particular substitution is not made
# Note: be careful if one of the subs is a regexp string (e.g. for client side
# form validation) - if you need the backslash to appear in the regexp, make sure
# you escape the backslash e.g. \\ instead of \
def sub_vars_in_trusted_str(str, *args)
	reg_whole_var = /%%\{[a-zA-Z0-9]{1,}?\}/
	reg_capture = /%%\{(?<varname>[a-zA-Z0-9]{1,}?)\}/
	changed_str = str.dup
	mdata_arr = str.scan(reg_whole_var)
	mdata_arr.each{|one_part_to_switch|
		if reg_capture.match?(one_part_to_switch)
			name_mdata = reg_capture.match(one_part_to_switch)
			if name_mdata[:varname] == "csrf"
				# sub the value given for csrf_field_for_form_v 
				changed_str.sub!(one_part_to_switch, csrf_field_for_form_v)
			else
				# it's not csrf, process normally
				varname_index = name_mdata[:varname].to_sym
				if (args.last.class == Hash) and (args.last.include?(varname_index))
					replace_by = args.last[varname_index]
					changed_str.sub!(one_part_to_switch, replace_by)
				end
			end
		end
	}
	changed_str
end

def url_decode(str)
	# carriage return %0D and line feed %0A are replaced with spaces here
	decoding_table = {"%0D" => " ", "%0A" => " ", "%21" => "!", "%22" => "\"", "%23" => "#", "%24" => "$",
		"%26" => "&", "%27" => "'", "%28" => "(", "%29" => ")", "%2A" => "*",
		"%2C" => ",", "%2E" => ".", "%2F" => "/", "%3A" => ":", "%3B" => ";",
		"%3C" => "<", "%3D" => "=", "%3E" => ">", "%3F" => "?", "%40" => "@",
		"%5B" => "[", "%5C" => "\\", "%5D" => "]", "%5E" => "^", "%5F" => "_",
	"%7B" => "{", "%7D" => "}", "%7E" => "~"}
	
	decoding_table.each_pair{|key,value|str.gsub!(key, value)}
	str
end

# Not expected to be called by user: use get_form_pars or get_query_pars instead
# Given a query substring, breaks it up into form parameters, returning an array of
# key-value hashes. The + symbol is treated as a space. For example, 
# query_substr = "thename=john&size=medium?reading=my+fave+book&music=fave+band"
# will return [{"thename"=>"john", "size"=>"medium"}, {"reading"=>"my fave book", "music"=>"fave band"}]
# This is provided as a simpler (but less rigorous) alternative to URI::decode_www_form
# String encoding here is whatever the default is for your ruby application
def get_form_and_query_pars(query_substr, sub_url_encode = true)
	result = Array.new
	unless query_substr == nil
		# first sub + for space
		spaced_substr = query_substr.gsub('+', ' ')
		# first split on query
		arrq = spaced_substr.split("?")
		arrq.each {|one_query|
			h = Hash.new
        	if one_query.include?("&amp;")
            	delim = "&amp;"
            else
            	delim = "&"
            end
			arrvalpair = one_query.split(delim)
			arrvalpair.each{|keyval|
            	ind = keyval.index("=")
            	if (ind != nil) and (ind > 0)
            		key = keyval[0..(ind - 1)]
            		value = keyval[(ind + 1)..(keyval.length - 1)]
            		if sub_url_encode == true
            			decoded = url_decode(value.dup)
            			h[key] = Sanitize.fragment(decoded, SANITIZE_DEFAULT)
            		else
            			h[key] = value
            		end
                end
			}
			result.push(h)
		}
	end
	return result
end

def get_form_pars(query_substr, sanitize = true)
	get_form_and_query_pars(query_substr, sanitize)[0]
end

def get_query_pars(query_substr, sanitize = true)
	get_form_and_query_pars(query_substr, sanitize)[1]
end

# given the plain path (i.e. without queries) and template map, determines 
# whether the path can be found in the template map
def req_path_in_templates(plain_path, template_map)
	result = Hash.new
	result[:found] = false
	if (defined?(template_map)) and (template_map.empty? == false)
		template_map.each {|one_template| 
			one_template[:pages].each {|one_page|
				if one_page[:url] == plain_path
					result[:found] = true
					result[:template_fn] = one_template[:template_fn]
					result[:locals] = one_page[:locals]
				end
		}}
	end
	return result
end

def remove_trailing_slashes(uri_req_path_str)
	reg_trailslash = /\/+$/
	uri_req_path_str.gsub(reg_trailslash, "")
end

def construct_url_from_server_and_relpath(relpath, protocol = "https", downcase = true)
	# this nmethod does not check for double slashes in URL but probably should
	if downcase
		protocol.downcase.strip + "://" + ENV['SERVER_NAME'].downcase.strip + relpath.downcase.strip
	else
		protocol.strip + "://" + ENV['SERVER_NAME'].strip + relpath.strip
	end
end

def refer_match_relpath?(refer_path, rel_path)
	variations = [construct_url_from_server_and_relpath(rel_path, "https"), construct_url_from_server_and_relpath(rel_path, "http")]
	variations.any?{|full_rel_path| remove_trailing_slashes(full_rel_path.downcase) == remove_trailing_slashes(refer_path.downcase)}
end

# used for matching requested paths to auto url directory
def rb_file_present?(url_path, dir)
	full_filename = dir.dup.concat("/", url_path, ".rb")
	File.exist?(full_filename)
end

def method_post?
	ENV['REQUEST_METHOD'] == "POST"
end

def method_get?
	ENV['REQUEST_METHOD'] == "GET"
end

